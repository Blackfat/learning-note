### 设计规范

1.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循:

- 不是频繁修改的字段。
- 不是 varchar 超长字段，更不能是 text 字段。

```
   正例: 使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。
```

2.【推荐】单表行数超过 500 万行或者单表容量超过 10GB，才推荐进行分库分表。 说明:如果预计2年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

3.【推荐】id必须是主键，每个表必须有主键，且保持增长趋势的，小型系统可以依赖于MySQL 的自增主键，大型系统或者需要分库分表时使用内置的 ID 生成器

4.【强制】主键id类型必须使用bigint unsigned，禁止使用int，即使现在的数据量很小，更不允许使用varchar (varchar的写入性能比bigint差)，如果需要有业务含义的varchar类型ID，该字段使用唯一索引。id如果是数字类型的话，必须是8个字节。

5.【推荐】字段尽量设置为 NOT NULL， 为字段提供默认值。 如字符型的默认值为一个空字符值串''; 数值型默认值为数值 0; 逻辑型的默认值为数值 0;

6.【推荐】时间统一格式: 'YYYY-MM-DD HH:MM:SS'

7.【强制】更新数据表记录时，必须同时更新记录对应的 update_time 字段值为当前时间



### **命名规范**

1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint ( 1表示是，0表示否)。

   说明: 任何字段如果为非负数，必须是 unsigned。

   正例: 表达逻辑删除的字段名 is_delete，1 表示删除，0 表示未删除。

2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。

 说明: MySQL 在Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。

3.【强制】表名不使用复数名词。 说明:表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯。

4.【强制】禁用保留字，如 desc、range、match、delayed、status等，请参考 MySQL 官方保留字。

5.【强制】主键索引名为 pk_字段名; 唯一索引名为 uk_字段名;普通索引名则为 idx_字段名。说明:pk_ 即 primary key;uk_ 即 unique key;idx_ 即 index 的简称。

6.【强制】小数类型为 decimal，禁止使用 float 和 double。

   说明: float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。

7.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。

8.【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。

9.【强制】表必备三字段:id, is_delete, create_time, update_time, 其中update_time字段必须有索引

   说明:其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。create_time, update_time 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被动更新。

   这里设计时间类型时，开发者应考虑时区问题，开发者的本地时需要转换成世界时之后再存到字段里面去。 这样数据库存储的时间就不会因为时区乱掉。

   另一种操作是一律存储 Unix 时间戳，timestamp 隐含了 0 时区。

   date_time 字段有时区问题，可以选用 timestamp 作为标准字段类型，timestamp size 小、索引效率高、并且没有时区问题（timestamp 唯一的缺点是 2038 问题）



### 类型规范

1. 表示状态字段(0-255)的使用 TINYINT UNSINGED，禁止使用枚举 类型，注释必须清晰地说明每个枚举的含义，以及是否多选等

2. 表示boolean类型的都使用TINYINT(1),因为mysql本身是没有boolean类型的，在自动生成代码的时候，DO对象的字段就是boolean类型，例如 is_delete;其余所有时候都使用TINYINT(4)

   ```
   TINYINT(4),这个括号里面的数值并不是表示使用多大空间存储，而是最大显示宽度，并且只有字段指定zerofill时有用，没有zerofill，(m)就是无用的,例如id BIGINT ZEROFILL NOT NULL, 所以建表时就使用默认就好了，不需要加括号了，除非有特殊需求，例如TINYINT(1)代表boolean类型。
   
   TINYINT(1)，TINYINT(4)都是存储一个字节，并不会因为括号里的数字改变。例如TINYINT(4)存储22则会显示0022，因为最大宽度为4，达不到的情况下用0来补充。
   ```

3. 特殊类型的数据

存储IP最好使用32位无符号整型，MySQL提供了函数inet_aton()和inet_ntoa()进行IP地址的数字表示和字符串表示之间的转换。

4. Blob 和 Text 类型所存储的数据量大，删除和修改操作容易在数 据表里产生大量的碎片，避免使用 Blob 或 Text 类型

5. 主键类型的选择

   尽可能使用整型，整型占用空间少，还可以设置为自动增长。尤其别使用GUID，MD5等哈希值字符串作为主键，这类字符串随机性很大，由于InnoDB主键默认是聚簇索引列，所以导致数据存储太分散。

   另外，InnoDB的二级索引列中默认包含主键列，如果主键太长，也会使得二级索引很占空间。

6. 时间类型

   - year
   - date
   - time
   - datetime
   - timestamp

   datetime存储范围是1001到9999，精确到秒,占用8个字节。

   timestamp存储1970年1月1日午夜以来的秒数，可以表示到2038年。占用4个字节，是datetime占用空间的一半。timestamp表示的时间和时区有关，另外timestamp列还有个特性，执行insert或update语句时，MySQL会自动更新第一个类型为timestamp的列的数据为当前时间。

   很多表中都有设计有一列叫做updateTime，这个列使用timestamp倒是挺合适的，会自动更新，前提是系统不会使用到2038年。



### 索引规范

1.【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。 说明:索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

2.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

> 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

3.【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。

> 正例: where a=? and b=? order by c; 索引: a_b_c
>
> 反例: 索引中有范围查找，那么索引有序性无法利用，如: WHERE a>10 ORDER BY b; 索引 a_b 无法排序。

4.【推荐】SQL 性能优化的目标:至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。

   说明:

- consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。
- ref 指的是使用普通的索引(normal index)。
- range 对索引进行范围检索。
  反例:explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级 别比较 range 还低，与全表扫描是小巫见大巫。

5.【推荐】建组合索引的时候，区分度最高的在最左边。
   正例:如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即 可。

> 说明:存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如:where a>? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。

6.【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。

7.总结

```
 　 • 索引占磁盘空间，不要重复的索引，尽量短  
    • 只给常用的查询条件加索引  
    • 过滤性高的列建索引，取值范围固定的列不建索引 
    • 唯一的记录添加唯一索引  
    • 频繁更新的列不要建索引  
    • 不要对索引列运算  
    • 同样过滤效果下，保持索引长度最小  
    • 合理利用组合索引，注意索引字段先后顺序  
    • 多列组合索引，过滤性高的字段最前  
    • order by 字段建立索引，避免 filesort  
    • 组合索引，不同的排序顺序不能使用索引  
    • <>!=无法使用索引
```

