### mysql架构

![mysql](https://user-images.githubusercontent.com/13096375/49052432-c013c400-f226-11e8-87f2-62e3066c7add.png)



### redolog和binlog

> redo log（重做日志）和 binlog（归档日志）

redo log是InnoDB引擎特有的日志，主要用来保证数据库发生异常重启后，之前提交的记录不会丢失，实现crash-safe。当数据库有一条语句需要更新的时候，InnoDB引擎会先把记录写到redo log中，记录做了哪些改动，并更新内存，这个时候更新就算完了，同时，在适当的时候，InnoDB引擎会将操作记录更新到磁盘里面。



binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。



redo log和binlog区别：

- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这 个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 
- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写 到一定大小后会切换到下一个，并不会覆盖以前的日志。 



```mysql
mysql> update t set c=c+1 where id=1;
```

执行逻辑：

- 执行器先找到执行引擎取id=1这行，id是主键，引擎直接通过索引搜索到这一行，如果id=1这行所在的数据页原本就在内存中，就直接返回给执行器，否则，需要先从磁盘加载到内存中，然后再返回。

- 执行器拿到引擎给的数据，把c+1,得到新的一行数据，再调用引擎接口写入这行数据。

- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 

- 执行器生成这个操作的 binlog，并把 binlog 写入磁盘 。

- 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完 成。 


### 事务隔离

事务的4个特性(ACID):

- 原子性(atomatic):组成一个事务的多个数据库操作时一个不可分割的原子单元。
- 一致性（Consistency）：事务完成后，数据库所处的状态和它的业务规则是一致的。
- 隔离性（isolation）：在并发数据操作时，不同事务之间互相隔离。
- 持久性（durability）：事务提交后，事务中的所有操作必须持久化到数据库中。 

事务并发：

- 脏读：A事务读取到了B事务未提交的事务。
- 不可重复读：A事务读取到了了B事务提交的更改或删除的数据。
- 幻读：A事务读取到了B事务提交的新增的数据。 

事务隔离级别:

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。 当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁 冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别 下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这 个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接 返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 

避免使用长事务

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所 以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 

```mysql
# 查询长事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60

```

事务隔离

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。 每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的 事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直 接拿到它。

InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的 up_limit_id（一致性视图）。

普通查询语句是一致性读，一致性读会根据 row trx_id 和 up_limit_id（一致性视图） 的大小决定数据版 本的可见性。 

对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 

对于读提交，查询只承认在语句启动前就已经提交完成的数据；

 而当前读，总是读取已经提交完成的最新版本。 

> 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读（current read）”。 除了 update 语句外，select 语句如果加锁，也是当前读

>  一个事务在启动的时候，找到所有已经提交的事务 ID 的最大值，记为 up_limit_id 。



### 索引

InnoDB 的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表 。索引类型分为主键索引和非主键索引 。每一个索引在 InnoDB 里面对应一棵 B+ 树 。B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数 。

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。 
- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 

主键索引和非主键索引的区别

- 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树； 
- 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 

索引优化

- 覆盖索引

  >索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。 
  >

- 最左前缀原则

  > 先要看第一列，在第一列满足的条件下再看左边第二列，以此类推 。最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符 

- 索引下推

  > 在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段 值。 MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满 足条件的记录，减少回表次数。    



### 锁

全局锁

> 全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以 下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新 类事务的提交语句。 

全局锁的典型应用场景是全库逻辑备份。InnoDB引擎支持可重复读的隔离级别下，使用官方自带的逻辑备份工具mysqldump，在 mysqldump 使用参数–single-transaction 的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以 正常更新的。 

表级锁

mysql的表锁分为表锁和元数据锁(MDL)

- 表锁的语法是 lock tables … read/write 。在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的 引擎，一般不使用 lock tables 命令来控制并发 。
- 在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结 构变更操作的时候，加 MDL 写锁。 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同 时给一个表加字段，其中一个要等另一个执行完才能开始执行。 


行锁

>行锁就是针对数据表中行记录的锁。比如事务 A 更新了一行，而这时候事务 B 也要更新 同一行，则必须等事务 A 的操作完成后才能进行更新 。

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务 结束时才释放。这个就是两阶段锁协议。 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放 。

间隙锁

>Innodb引擎在隔离级别为可重复读下引入间隙锁(Grap Lock),锁的就是两个值之间的空隙。

next-key lock

> 间隙锁和行锁合称 next-key lock，每个 next-key lock是前开后闭区间

加锁规则

1. 原则 1：加锁的基本单位是 next-key lock。
2. 原则 2：查找过程中访问到的对象才会加锁。 
3. 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
4. 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退 化为间隙锁。 
5. 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止 



###  普通索引和唯一索引

`change buffer`

> 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从 磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性 。
>
> 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 purge。除了访问这个数据页 会触发 purge 外，系统有后台线程会定期 purge。在数据库正常关闭（shutdown）的过程中，也会 执行 purge 操作。 

唯一索引

唯一索引所有的更新操作都要先判断这个操作是否违反唯一性约束，必须将数据页读入内存才能判断。所以唯一索引不能使用change buffer

普通索引

普通索引更新操作的时候，如果数据页不在内存中，会将更新记录在change buffer中，语句执行就结束了。

`change buffer`的使用场景

对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用 效果最好。这种业务模型常见的就是账单类、日志类的系统 。

对于业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer， 但之后由于马上要访问这个数据页，会立即触发 purge 过程。这样随机访问 IO 的次数不会减少，反而 增加了 change buffer 的维护代价。 

###脏页和干净页

>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘
>后，内存和磁盘上的数据页的内容就一致了，称为“干净页"

### count

对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。 

对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数 字“1”进去，判断是不可能为空的，按行累加。

对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返 回 id 会涉及到解析数据行，以及拷贝字段值的操作。 

对于 count(字段) 来说： 

1. 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null， 按行累加；
2. 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判 断一下，不是 null 才累加。 

按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(*)

###  rowid

>每个引擎用来唯一标识数据行的信息

- 对于有主键的innodb表来说，这rowid就是主键id
- 对于没有主键的innodb表来说，这个rowid是系统生成的


