### mysql架构

![mysql](https://user-images.githubusercontent.com/13096375/49052432-c013c400-f226-11e8-87f2-62e3066c7add.png)



### redolog和binlog

> redo log（重做日志）和 binlog（归档日志）

redo log是InnoDB引擎特有的日志，主要用来保证数据库发生异常重启后，之前提交的记录不会丢失，实现crash-safe。当数据库有一条语句需要更新的时候，InnoDB引擎会先把记录写到redo log中，记录做了哪些改动，并更新内存，这个时候更新就算完了，同时，在适当的时候，InnoDB引擎会将操作记录更新到磁盘里面。



binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。



redo log和binlog区别：

- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这 个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 
- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写 到一定大小后会切换到下一个，并不会覆盖以前的日志。 



```mysql
mysql> update t set c=c+1 where id=1;
```

执行逻辑：

- 执行器先找到执行引擎取id=1这行，id是主键，引擎直接通过索引搜索到这一行，如果id=1这行所在的数据页原本就在内存中，就直接返回给执行器，否则，需要先从磁盘加载到内存中，然后再返回。
- 执行器拿到引擎给的数据，把c+1,得到新的一行数据，再调用引擎接口写入这行数据。
- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 
- 执行器生成这个操作的 binlog，并把 binlog 写入磁盘 。
- 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完 成。 

mysql异常恢复的原则：

- 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交 。

- 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：

   a. 如果是，则提交事务； b. 否则，回滚事务。

mysql判断binlog完整的原则：

- statement格式的binlog，一个完成的事务最后会有commit标识
- row格式的binlog，一个完成的事务会有XID event


### 事务隔离

事务的4个特性(ACID):

- 原子性(atomatic):组成一个事务的多个数据库操作时一个不可分割的原子单元。
- 一致性（Consistency）：事务完成后，数据库所处的状态和它的业务规则是一致的。
- 隔离性（isolation）：在并发数据操作时，不同事务之间互相隔离。
- 持久性（durability）：事务提交后，事务中的所有操作必须持久化到数据库中。 

事务并发：

- 脏读：A事务读取到了B事务未提交的事务。
- 不可重复读：A事务读取到了了B事务提交的更改或删除的数据。
- 幻读：A事务读取到了B事务提交的新增的数据。 

事务隔离级别:

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。 当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁 冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别 下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这 个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接 返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 

避免使用长事务

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所 以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 

```mysql
# 查询长事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60

```

事务隔离

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。 每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的 事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直 接拿到它。

InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的 up_limit_id（一致性视图）。

普通查询语句是一致性读，一致性读会根据 row trx_id 和 up_limit_id（一致性视图） 的大小决定数据版 本的可见性。 

对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 

对于读提交，查询只承认在语句启动前就已经提交完成的数据；

 而当前读，总是读取已经提交完成的最新版本。 

> 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读（current read）”。 除了 update 语句外，select 语句如果加锁，也是当前读

>  一个事务在启动的时候，找到所有已经提交的事务 ID 的最大值，记为 up_limit_id 。



### 索引

InnoDB 的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表 。索引类型分为主键索引和非主键索引 。每一个索引在 InnoDB 里面对应一棵 B+ 树 。B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数 。

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。 
- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 

主键索引和非主键索引的区别

- 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树； 
- 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 

索引优化

- 覆盖索引

  >索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。 
  >

- 最左前缀原则

  > 先要看第一列，在第一列满足的条件下再看左边第二列，以此类推 。最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符 

- 索引下推

  > 在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段 值。 MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满 足条件的记录，减少回表次数。    



### 锁

全局锁

> 全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以 下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新 类事务的提交语句。 

全局锁的典型应用场景是全库逻辑备份。InnoDB引擎支持可重复读的隔离级别下，使用官方自带的逻辑备份工具mysqldump，在 mysqldump 使用参数–single-transaction 的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以 正常更新的。 

表级锁

mysql的表锁分为表锁和元数据锁(MDL)

- 表锁的语法是 lock tables … read/write 。在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的 引擎，一般不使用 lock tables 命令来控制并发 。
- 在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结 构变更操作的时候，加 MDL 写锁。 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同 时给一个表加字段，其中一个要等另一个执行完才能开始执行。 


行锁

>行锁就是针对数据表中行记录的锁。比如事务 A 更新了一行，而这时候事务 B 也要更新 同一行，则必须等事务 A 的操作完成后才能进行更新 。innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。 

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务 结束时才释放。这个就是两阶段锁协议。 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放 。

间隙锁

>Innodb引擎在隔离级别为可重复读下引入间隙锁(Grap Lock),锁的就是两个值之间的空隙。

next-key lock

> 间隙锁和行锁合称 next-key lock，每个 next-key lock是前开后闭区间

加锁规则

1. 原则 1：加锁的基本单位是 next-key lock。
2. 原则 2：查找过程中访问到的对象才会加锁。 
3. 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
4. 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退 化为间隙锁。 
5. 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止 



###  普通索引和唯一索引

`change buffer`

> 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从 磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性 。
>
> 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 purge。除了访问这个数据页 会触发 purge 外，系统有后台线程会定期 purge。在数据库正常关闭（shutdown）的过程中，也会 执行 purge 操作。 

唯一索引

唯一索引所有的更新操作都要先判断这个操作是否违反唯一性约束，必须将数据页读入内存才能判断。所以唯一索引不能使用change buffer

普通索引

普通索引更新操作的时候，如果数据页不在内存中，会将更新记录在change buffer中，语句执行就结束了。

`change buffer`的使用场景

对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用 效果最好。这种业务模型常见的就是账单类、日志类的系统 。

对于业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer， 但之后由于马上要访问这个数据页，会立即触发 purge 过程。这样随机访问 IO 的次数不会减少，反而 增加了 change buffer 的维护代价。 

###脏页和干净页

>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘
>后，内存和磁盘上的数据页的内容就一致了，称为“干净页"

### count

对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。 

对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数 字“1”进去，判断是不可能为空的，按行累加。

对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返 回 id 会涉及到解析数据行，以及拷贝字段值的操作。 

对于 count(字段) 来说： 

1. 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null， 按行累加；
2. 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判 断一下，不是 null 才累加。 

按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(*)

###  rowid

>每个引擎用来唯一标识数据行的信息

- 对于有主键的innodb表来说，这rowid就是主键id
- 对于没有主键的innodb表来说，这个rowid是系统生成的

### 内存表和临时表

内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种 表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。 

临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数 据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。 临时表特点：

1. 建表语法是 create temporary table …。
2. 一个临时表只能被创建它的 session 访问，对其他线程不可见。
3. 临时表可以与普通表同名。
4. session  内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的 是临时表。 
5. show tables 命令不显示临时表。 

### group by 优化

1. 如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null； 
2. 尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；
3. 如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表； 

### InnoDB引擎和Memory引擎

>- InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索 引组织表（Index Organizied Table）。 
>-  Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之 为堆组织表（Heap Organizied Table）。 

1. InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；
2. 当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固 定的位置写入新值，而内存表找到空位就可以插入新值；
3. 数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引； 
4. InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引 查找。而内存表没有这个区别，所有索引的“地位”都是相同的。 
5. InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并 且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表 的每行数据长度相同。 

### 表结构复制

- as用来创建相同表结构并复制源表数据 
- like用来创建完整表结构和全部索引 
- oracle支持as，也是只有表结构没有索引，oracle不支持like 
- 两种方式在复制表的时候均不会复制权限对表的设置 