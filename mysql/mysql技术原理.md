

### mysql架构

![mysql](https://user-images.githubusercontent.com/13096375/49052432-c013c400-f226-11e8-87f2-62e3066c7add.png)



### redolog和binlog

> redo log（重做日志）和 binlog（归档日志）

redo log是InnoDB引擎特有的日志，主要用来保证数据库发生异常重启后，之前提交的记录不会丢失，实现crash-safe。当数据库有一条语句需要更新的时候，InnoDB引擎会先把记录写到redo log中，记录做了哪些改动，并更新内存，这个时候更新就算完了，同时，在适当的时候，InnoDB引擎会将操作记录更新到磁盘里面。



binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。



redo log和binlog区别：

- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这 个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 
- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写 到一定大小后会切换到下一个，并不会覆盖以前的日志。 



```mysql
mysql> update t set c=c+1 where id=1;
```

执行逻辑：

- 执行器先找到执行引擎取id=1这行，id是主键，引擎直接通过索引搜索到这一行，如果id=1这行所在的数据页原本就在内存中，就直接返回给执行器，否则，需要先从磁盘加载到内存中，然后再返回。
- 执行器拿到引擎给的数据，把c+1,得到新的一行数据，再调用引擎接口写入这行数据。
- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 
- 执行器生成这个操作的 binlog，并把 binlog 写入磁盘 。
- 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完 成。 

mysql异常恢复的原则：

- 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交 。

- 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：

   a. 如果是，则提交事务； b. 否则，回滚事务。

mysql判断binlog完整的原则：

- statement格式的binlog，一个完成的事务最后会有commit标识
- row格式的binlog，一个完成的事务会有XID event


### 事务隔离

事务的4个特性(ACID):

- 原子性(atomatic):组成一个事务的多个数据库操作时一个不可分割的原子单元。
- 一致性（Consistency）：事务完成后，数据库所处的状态和它的业务规则是一致的。
- 隔离性（isolation）：在并发数据操作时，不同事务之间互相隔离。
- 持久性（durability）：事务提交后，事务中的所有操作必须持久化到数据库中。 

事务并发：

- 脏读：A事务读取到了B事务未提交的事务。
- 不可重复读：A事务读取到了了B事务提交的更改或删除的数据。
- 幻读：A事务读取到了B事务提交的新增的数据。 

事务隔离级别:

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。 当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁 冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 

在实现上，数据库里面会创建一个视图(read view，活跃的事务id)，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别 下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这 个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接 返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 

事务隔离实现：

在 MySQL 中，实际上每条记录在更新的时候都会同时记录undolog。记录上的最新值，通过undolog，都可以得到前一个状态的值。当系统里没有比这个回滚日志更早的 read-view 的时候，回滚日志会被删除。

避免使用长事务

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所 以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 

```mysql
# 查询长事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60

```

幻读

> 幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。
>
> 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。

事务隔离

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。 每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的 事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直 接拿到它。

InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的 up_limit_id（一致性视图）。

普通查询语句是一致性读，一致性读会根据 row trx_id 和 up_limit_id（一致性视图） 的大小决定数据版 本的可见性。 

对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 

对于读提交，查询只承认在语句启动前就已经提交完成的数据；

 而当前读，总是读取已经提交完成的最新版本。 

> 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读（current read）”。 除了 update 语句外，select 语句如果加锁，也是当前读

>  一个事务在启动的时候，找到所有已经提交的事务 ID 的最大值，记为 up_limit_id 。

MVCC

MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的版本链的过程，这样子可以使不同事务的`读-写`、`写-读`操作并发执行，从而提升系统性能。`READ COMMITTD`、`REPEATABLE READ`这两个隔离级别的一个很大不同就是生成`ReadView`的时机不同，`READ COMMITTD`在每一次进行普通`SELECT`操作前都会生成一个`ReadView`，而`REPEATABLE READ`只在第一次进行普通`SELECT`操作前生成一个`ReadView`，之后的查询操作都重复这个`ReadView`就好了。

`ReadView`可以理解成InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。

当前读

可读已提交事务的最新数据

快照读

创建快照时，还没提交的事务不可见；创建快照之后创建的事务不可见

可见性判断

- 数据事务id比最小的活跃事务id小，数据可见
- 数据事务id比最大的活跃事务id大，数据不可见
- 数据事务id在最小的活跃事务id和最大活跃事务id之间且数据事务id在活跃事务id中，数据不可见

### 索引

InnoDB 的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表 。索引类型分为主键索引和非主键索引 。每一个索引在 InnoDB 里面对应一棵 B+ 树 。B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数 。

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。 
- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 

主键索引和非主键索引的区别

- 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树； 
- 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 

索引优化

- 覆盖索引

  >索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。 
  >

- 最左前缀原则

  > 先要看第一列，在第一列满足的条件下再看左边第二列，以此类推 。最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符 

- 索引下推

  > 在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段 值。 MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满 足条件的记录，减少回表次数。    



### 锁

> 共享锁(S)和排他锁(X)，当前读会加排他锁(select for update|update|delete)

全局锁

> 全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以 下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新 类事务的提交语句。 

全局锁的典型应用场景是全库逻辑备份。InnoDB引擎支持可重复读的隔离级别下，使用官方自带的逻辑备份工具mysqldump，在 mysqldump 使用参数–single-transaction 的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以 正常更新的。 

表级锁

mysql的表锁分为表锁和元数据锁(MDL)

- 表锁的语法是 lock tables … read/write 。在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的 引擎，一般不使用 lock tables 命令来控制并发 。
- 在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结 构变更操作的时候，加 MDL 写锁。 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同 时给一个表加字段，其中一个要等另一个执行完才能开始执行。 


行锁

>行锁就是针对数据表中行记录的锁。比如事务 A 更新了一行，而这时候事务 B 也要更新 同一行，则必须等事务 A 的操作完成后才能进行更新 。innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。 

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务 结束时才释放。这个就是两阶段锁协议。 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放 。

间隙锁

>Innodb引擎在隔离级别为可重复读下引入间隙锁(Grap Lock),锁的就是两个值之间的空隙。

next-key lock

> 间隙锁和行锁合称 next-key lock，每个 next-key lock是前开后闭区间

加锁规则

1. 原则 1：加锁的基本单位是 next-key lock。
2. 原则 2：查找过程中访问到的对象才会加锁。 
3. 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
4. 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退 化为间隙锁。 
5. 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止 



###  普通索引和唯一索引

`change buffer`

> 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从 磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性 。
>
> 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 purge。除了访问这个数据页 会触发 purge 外，系统有后台线程会定期 purge。在数据库正常关闭（shutdown）的过程中，也会 执行 purge 操作。 

唯一索引

唯一索引所有的更新操作都要先判断这个操作是否违反唯一性约束，必须将数据页读入内存才能判断。所以唯一索引不能使用change buffer

普通索引

普通索引更新操作的时候，如果数据页不在内存中，会将更新记录在change buffer中，语句执行就结束了。

`change buffer`的使用场景

对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用 效果最好。这种业务模型常见的就是账单类、日志类的系统 。

对于业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer， 但之后由于马上要访问这个数据页，会立即触发 purge 过程。这样随机访问 IO 的次数不会减少，反而 增加了 change buffer 的维护代价。 

###脏页和干净页

>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘
>后，内存和磁盘上的数据页的内容就一致了，称为“干净页"

### count

对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。 

对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数 字“1”进去，判断是不可能为空的，按行累加。

对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返 回 id 会涉及到解析数据行，以及拷贝字段值的操作。 

对于 count(字段) 来说： 

1. 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null， 按行累加；
2. 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判 断一下，不是 null 才累加。 

按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(*)

###  rowid

>每个引擎用来唯一标识数据行的信息

- 对于有主键的innodb表来说，这rowid就是主键id
- 对于没有主键的innodb表来说，这个rowid是系统生成的

### 内存表和临时表

内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种 表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。 

临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数 据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。 临时表特点：

1. 建表语法是 create temporary table …。
2. 一个临时表只能被创建它的 session 访问，对其他线程不可见。
3. 临时表可以与普通表同名。
4. session  内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的 是临时表。 
5. show tables 命令不显示临时表。 

### group by 优化

1. 如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null； 
2. 尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；
3. 如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表； 

### InnoDB引擎和Memory引擎

>- InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索 引组织表（Index Organizied Table）。 
>-  Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之 为堆组织表（Heap Organizied Table）。 

1. InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；
2. 当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固 定的位置写入新值，而内存表找到空位就可以插入新值；
3. 数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引； 
4. InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引 查找。而内存表没有这个区别，所有索引的“地位”都是相同的。 
5. InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并 且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表 的每行数据长度相同。 

### 表结构复制

- as用来创建相同表结构并复制源表数据 
- like用来创建完整表结构和全部索引 
- oracle支持as，也是只有表结构没有索引，oracle不支持like 
- 两种方式在复制表的时候均不会复制权限对表的设置 

### 执行计划参数

type

- const：数据表最多只有一个匹配行 ，常用于PRIMARY KEY或者UNIQUE索引的查询。
- eq_ref:对于驱动表的行组合，从被驱动表读取一行， 最好的连接类型。常用于使用=号比较带索引的列。
- ref:ref可用于=或<或>操作符的带索引的列。
- range ：只检索给定范围的行,使用一个索引来选择行 。
- index：只有索引树被扫描 
- ALL ：全表扫描

extra

- Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行 
- Using filesort:MySQL需要排序,以找出如何按排序顺序检索行 
- Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息 
- Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果 

### 索引失效

- 对索引字段做函数操作，可能会破会索引值的有序性

- 字符串和数字比较，隐式通过函数将字符串转出成数字

- utf-8和utf-8mb4字段连接时，索引失效的原因

  字符集不同，连接过程中在被驱动表的索引字段上加上函数操作，导致索引失效

###binlog 的三种格式

statement格式

记录到binlog中的是sql语句原文，slave在复制的时候sql进程会解析成master端执行过的相同的sql在slave库上再次执行。

row格式

记录到binlog中的是每一行数据修改的形式，然后在slave端再对相同的数据进行修改。

mix格式

mysql会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也是在statement和row之间选择一种。

对比

 statement 格式的 binlog 中一些新功能同步可能会有障碍,比如函数、触发器，可能会导致主备不一致。所以要使用 row 格式。但 row 格式的缺点是，占用空间，同时io压力大。mixed 格式做了这种的方案，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。



### 事务实现原理

mvcc

- 多版本的并发控制

- 解决读写冲突

- 隐藏列(**`DB_TRX_ID，``DB_ROLL_PTR，``DB_ROW_ID`**)

`ReadView`可以理解成InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。

当前读

可读已提交事务的最新数据

快照读

创建快照时，还没提交的事务不可见；创建快照之后创建的事务不可见

可见性判断

- 数据事务id比最小的活跃事务id小，数据可见
- 数据事务id比最大的活跃事务id大，数据不可见
- 数据事务id在最小的活跃事务id和最大活跃事务id之间且数据事务id在活跃事务id中，数据不可见

undolog

- 回滚日志
- 保证事务原子性
- 实现数据多版本

redolog

- 实现事务的持久性

- 减少随机写磁盘的消耗转为顺序写

### buffer pool

> 应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在**缓存**(cache)里，避免每次都去访问数据库。操作系统，会有**缓冲池**(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。MySQL作为一个存储系统，同样具有**缓冲池**(buffer pool)机制，以避免每次查询数据都进行磁盘IO。

**总结**

（1）缓冲池(buffer pool)是一种**常见的降低磁盘访问的机制；**

（2）缓冲池通常**以页(page)为单位缓存数据；**

（3）缓冲池的**常见管理算法是LRU**，memcache，OS，InnoDB都使用了这种算法；

（4）InnoDB对普通LRU进行了优化：

- 将缓冲池分为**老生代和新生代**，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题
- 页被访问，且在老生代**停留时间超过配置阈值**的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题

### log buffer 和 change buffer

log buffer

对InnoDB表进行更改时，这些更改首先存储在InnoDB 的log buffer，然后写入通常称为重做日志（redo logs）的InnoDB log file中。(innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘,可以保证 MySQL 异常重启之后数据不丢失。)

change buffer 

写缓存（change Buffer） 是一种特殊的数据结构，**用于在对数据变更时，如果数据所在的数据页没有在 buffer pool 中的话，在不影响数据一致性的前提下，InnoDB 引擎会将对数据的操作缓存在 Change Buffer 中**，这样就省去了从磁盘中读入这个数据页。将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。如果数据库都是唯一索引，那么在每次操作的时候都需要判断索引是否有冲突，势必要将数据加载到缓存中对比，因此也用不到 Change Buffer。change buffer 主要节省的则是随机读磁盘的 IO 消耗。

### 主备一致

备库设置成(只读)readonly模式(readonly 设置对超级 (super) 权限用户是无效的，而用于同步更新的线程，就拥有超级权限)

- 有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；

- 防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；

- 可以用 readonly 状态，来判断节点的角色。

事务日志同步的流程：

- 在备库上通过 change master 命令，设置主库  的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。

- 在备库上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。
- 主库 校验完用户名、密码后，开始按照备库  传过来的位置，从本地读取 binlog，发给备库。
- 备库拿到 binlog 后，写到本地文件，称为中转日志（relay log）
- sql_thread 读取中转日志，解析出日志里的命令，并执行。