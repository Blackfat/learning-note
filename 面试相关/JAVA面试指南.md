### java基础

1.List，Set，Map的区别

List,Set都继承Collection接口，Map是键值对的集合，不允许key重复

List元素有放入顺序，元素可以重复；Set元素无放入顺序，元素不可重复，重复的元素会被覆盖掉

2.HashSet 是如何保证元素不重复的 

HashSet底层通过HashMap实现，首选元素的hashCode获取元素的存储位置，如果当前位置没有元素则加入，如果已经存在，这时会调用 equals 方法来检查 hashcode 相等的对象是否真的相同 ，如果相同则不能加入，如果不同则可以加入。

3.HashMap是线程安全的

HashMap不是线程安全的，在多线程同时操作的情况下，有可能出现循环链表，造成cpu使用率100%

4.HashMap 的扩容过程 

HashMap使用的是懒加载，构造完HashMap对象后，只要不进行put 方法插入元素之前，HashMap并不会去初始化或者扩容table。扩容过程中新table大小变为原来的2倍，接下来将原table中的元素重新hash后已到新table中

5.HashMap 1.7 与 1.8 的 区别 

扩容后元素的存储位置和计算方式不同：1.7中直接使用元素的（hash值 & length-1)(这里也可以解释为什么扩容大小一定要是2的倍数，可以最大程度的减少哈希碰撞)；1.8中根据hash新增参与运算的位是0还是1直接计算出扩容后的存储位置，如果新增参与运算的位是0，则扩容后的位置等于原始位置，如果新增参与运算的位是1，扩容后的位置等于原始位置加上扩容钱table的大小。 
1.7的时候使用的是数组+ 单链表的数据结构。但是在1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（nlogN）提高了效率）

6.强引用，软引用，弱引用

只要某个对象有强引用与之关联，JVM必定不会回收这个对象 

对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象 

当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象 

### java并发

1.synchronized 的实现原理以及锁优化 

当声明synchronized代码块时， 编译而成的字节码将包含 monitorenter 和 monitorexit 指令 。当执行 monitorenter 时，如果目标锁对象的计数器为 0，那么说明它没有被其他线程所持有。 在这个情况下，Java 虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加 1。 在目标锁对象的计数器不为 0 的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机 可以将其计数器加 1，否则需要等待，直至持有线程释放该锁。 锁一共有四种状态，无状态锁，偏向锁，轻量级锁，重量级锁，锁状态会随着锁竞争情况逐渐升级，锁状态可以升级但不能降级。

2.volatile的实现原理

编译器会在volatile读写前后插入一些内存屏障的指令，可以强制刷新处理器的写缓存(在碰到内存写操作时，处理器并不会等待该指令结束，而是直接开始下一指令，并且依赖于写缓 存将更改的数据同步至主内存（main memory）之中。 )。强制刷新写缓存，将使得当前线程写入volatile的值同步至主内存中，由于内存写操作同时会无效化其他处理器所持有的、指向同一内存地址的缓存行，因此可以认为 其他处理器能够立即见到该 volatile 字段的最新值。 

3.cas，cas的缺陷，如何解决

4.synchronized 和 lock 有什么区别 

1.Lock是一个接口，而synchronized是java 的关键字，synchronized是内置的语义实现的
2.synchronized在发生异常时，会自动释放锁，而Lock在发生异常，如果没有主动通过unlock释放锁，可能造成死锁
3.Lock可以让等待锁的线程响应中断，而synchronized时，等待的线程会一直等待下去，不能响应中断
4.通过Lock可以知道有没有成功获得锁，而synchronized的不行
5.Lock可以提高多个线程并发读操作的效率
6.synchronized是非公平锁，无法保证线程获取锁的顺序。而Lock可以设置为公平锁

5.AQS 

6.如何检测死锁？怎么预防死锁 

当有线程获取锁的时候，记录下来，相同，如果有线程请求锁，也会记录下来，当有线程请求锁失败时，需要检测是否已经产生死锁。

预防死锁：设置锁的有效时间

7.Java 内存模型 

8.线程池的种类，区别和使用场景 

9.ThreadLocal原理，用的时候需要注意什么 

通过threadLocal.set方法将对象实例保存在每个线程所拥有的threadLocalMap中，这个每个线程使用自己的对象实例，彼此不会影响互相隔离。每次使用完ThreadLocal，都调用它的remove()方法，清除数据 ，防止内存泄露。

### spring

### 分布式相关

### 缓存

### JVM

