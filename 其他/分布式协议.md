### CAP理论

CAP 理论对分布式系统的特性做了高度抽象，形成了三个指标:

- 一致性（Consistency）
- 可用性（Availability）
- 分区容错性（Partition Tolerance）

### Paxos算法

####Base-Paxos

>Basic Paxos 算法，描述的是多节点之间如何就某个值（提案 Value）达成共识；

Base-Paxos中的三种角色：

提议者：提议一个值，用于投票表决。提议者代表的是接入和协调功能，收到客户端请求后，发起二阶段提交，进行共识协商。

接受者：对每个提议的值进行投票，并存储接受的值。接受者代表投票协商和存储数据，对提议的值进行投票，并接受达成共识的值，存储保存。

学习者：被告知投票的结果，接受达成共识的值，存储保存，不参与投票的过程。学习者代表存储数据，不参与共识协商，只接受达成共识的值，存储保存。

Base-Paxos通过二阶段提交的方式来达成共识：

准备（Prepare）阶段（在准备请求中是不需要指定提议的值的，只需要携带提案编号就可以了）

接受（Accept）阶段（提议者收到大多数响应请求后，准备发送接入请求）

二阶段中接受者遵循的规则：

- 如果准备请求的提案编号，小于等于接受者已经响应的准备请求的提案编号，那么接受者将承诺不响应这个准备请求。

- 如果接受请求中的提案的提案编号，小于接受者已经响应的准备请求的提案编号，那么接受者将承诺不通过这个提案。

- 如果接受者之前有通过提案，那么接受者将承诺，会在准备请求的响应中，包含已经通过的最大编号的提案信息。



#### Multi-Paxos

> Multi-Paxos 是一种思想，不是算法。而 Multi-Paxos 算法是一个统称，它是指基于 Multi-Paxos 思想，通过多个 Basic Paxos 实例实现一系列值的共识的算法（比如 Chubby 的 Multi-Paxos 实现、Raft 算法等）



### Raft算法

>Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。

***领导者选举***

> 在 Raft 中，不是所有节点都能当选领导者，只有日志较完整的节点（也就是日志完整度不比半数节点低的节点），才能当选领导者；其次，在 Raft 中，日志必须是连续的。

成员身份：领导者、跟随者、候选人

**跟随者**：默默地接收和处理来自领导者的消息，当等待领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。

**候选人**：候选人将向其他节点发送请求投票RPC 消息，通知其他节点来投票，如果赢得了大多数选票，就晋升当领导者。

**领导者**：主要工作内容就是 3 部分，处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们现在不要发起新的选举，找个新领导者来替代我。”

Raft 算法实现了随机超时时间的特性。也就是说，每个节点等待领导者节点心跳信息的超时时间间隔是随机的。

节点通讯

服务器节点间的沟通联络采用的是远程过程调用（RPC)，在领导者选举中，需要用到这样两类的 RPC：

- 请求投票（RequestVote）RPC，是由候选人在选举期间发起，通知各节点进行投票；
- 日志复制（AppendEntries）RPC，是由领导者发起，用来复制日志和提供心跳消息。(日志复制 RPC 只能由领导者发起)

任期

Raft 算法中的领导者也是有任期的，每个任期由单调递增的数字（任期编号）标识。

Raft 算法中的任期不只是时间段，而且任期编号的大小，会影响领导者选举和请求的处理。

- 约定如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态。比如分区错误恢复后，任期编号为 3 的领导者节点 B，收到来自新领导者的，包含任期编号为 4 的心跳消息，那么节点 B 将立即恢复成跟随者状态。
- 约定如果一个节点接收到一个包含较小的任期编号值的请求，那么它会直接拒绝这个请求。比如节点 C 的任期编号为 4，收到包含任期编号为 3 的请求投票 RPC 消息，那么它将拒绝这个消息。

选举规则

- 领导者周期性地向所有跟随者发送心跳消息（即不包含日志项的日志复制 RPC 消息），通知大家我是领导者，阻止跟随者发起新的选举。
- 如果在指定时间内，跟随者没有接收到来自领导者的消息，那么它就认为当前没有领导者，推举自己为候选人，发起领导者选举。
- 在一次选举中，赢得大多数选票的候选人，将晋升为领导者。
- 在一个任期内，领导者一直都会是领导者，直到它自身出现问题（比如宕机），或者因为网络延迟，其他节点发起一轮新的选举。
- 在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，并且按照“先来先服务”的原则进行投票。
- 日志完整性高的跟随者（也就是最后一条日志项对应的任期编号值更大，索引号更大），拒绝投票给日志完整性低的候选人。

  随机超时

 使用随机选举超时时间的方法，把超时时间都分散开来，在大多数情况下只有一个服务器节点先发起选举，而不是同时发起选举，这样就能减少因选票瓜分导致选举失败的情况。

- 跟随者等待领导者心跳信息超时的时间间隔，是随机的；
- 如果候选人在一个随机时间间隔内，没有赢得过半票数，那么选举无效了，然后候选人发起新一轮的选举，等待选举超时的时间间隔，是随机的。

***日志复制***

> 副本数据是以日志的形式存在的，日志是由日志项组成。日志项是一种数据格式，它主要包含用户指定的数据，也就是指令（Command），还包含一些附加信息，比如索引值（Log index）、任期编号（Term）。

Raft 的日志复制理解成一个优化后的二阶段提交（将二阶段优化成了一阶段），减少了一半的往返消息，也就是降低了一半的消息延迟。

>二阶段是要所有的节点回复，而raft 只要半数节点回复就ok 减少了一部分等待时间。

- 接收到客户端请求后，领导者基于客户端请求中的指令，创建一个新日志项，并附加到本地日志中。
- 领导者通过日志复制 RPC，将新的日志项复制到其他的服务器。
- 当领导者将日志项，成功复制到大多数的服务器上的时候，领导者会将这条日志项应用到它的状态机中。
- 领导者将执行的结果返回给客户端。
- 当跟随者接收到心跳信息，或者新的日志复制 RPC 消息后，如果跟随者发现领导者已经提交了某条日志项，而它还没应用，那么跟随者就将这条日志项应用到本地的状态机中。

***成员变更***

单节点变更是利用“一次变更一个节点，不会同时存在旧配置和新配置 2 个‘大多数’”的特性，实现成员变更。

### ZAB协议

ZAB中的三种角色：

- 领导者（Leader）： 作为主（Primary）节点，在同一时间集群只会有一个领导者。需要你注意的是，所有的写请求都必须在领导者节点上执行。

- 跟随者（Follower）：作为备份（Backup）节点， 集群可以有多个跟随者，它们会响应领导者的心跳，并参与领导者选举和提案提交的投票。需要注意的是，跟随者可以直接处理并响应来自客户端的读请求，但对于写请求，跟随者需要将它转发给领导者处理。

- 观察者（Observer）：作为备份（Backup）节点，类似跟随者，但是没有投票权，也就是说，观察者不参与领导者选举和提案提交的投票。

ZAB中的角色状态：

- LOOKING：选举状态，该状态下的节点认为当前集群中没有领导者，会发起领导者选举。

- FOLLOWING ：跟随者状态，意味着当前节点是跟随者。

- LEADING ：领导者状态，意味着当前节点是领导者。

- OBSERVING： 观察者状态，意味着当前节点是观察者。

ZAB 定义了 4 种状态，来标识节点的运行状态：***只有当集群大多数节点处于广播状态的时候，集群才能提交提案。***

- ELECTION（选举状态）：表明节点在进行领导者选举。
- DISCOVERY（成员发现状态）：表明节点在协商沟通领导者的合法性。
- SYNCHRONIZATION（数据同步状态）：表明集群的各节点以领导者的数据为准，修复数据副本的一致性。
- BROADCAST（广播状态）：表明集群各节点在正常处理写请求。

领导的选举：

- 领导者选举的目标，是选举出大多数节点中数据最完整的节点，也就是大多数节点中事务标识符值最大的节点。
- 任期编号、事务标识符最大值、集群 ID 的值的大小，决定了哪个节点更适合作为领导者，按照顺序，值大的节点更适合作为领导者。

ZAB的故障恢复:

 成员发现：

- 领导者选举结束，节点进入跟随者状态或者领导者状态后，它们会分别设置 ZAB 状态为成员发现。
- 跟随者会主动联系领导者，发送自己已接受的领导者任期编号最大值（也就是 acceptedEpoch）的FOLLOWINFO 消息给领导者
- 接收到来自跟随者的 FOLLOWINFO 消息后领导者将创建包含自己事务标识符最大值的 LEADINFO 消息，并响应给跟随者。
- 接收到来自领导者的 LEADINFO 消息后，跟随者会基于领导者的任期编号，判断领导者是否合法，如果领导者不合法，跟随者发起新的选举，如果领导者合法，响应 ACKEPOCH 消息给领导者。
- 跟随者设置 ZAB 状态为数据同步
- 当领导者接收到来自大多数节点的 ACKEPOCH 消息后，领导者将设置 ZAB 状态为数据同步。

数据同步：

- 根据跟随者的事务标识符最大值，选取数据同步的方式，并将相关数据缓存在发送队列中。
- 领导者创建 NEWLEADER 消息，并缓存在发送队列中。
- 领导者启动一个新线程，并将缓存的数据发送给跟随者。
- 跟随者处理领导者的数据同步。
- 跟随者接收到来自领导者的 NEWLEADER 消息后，返回确认响应给领导者。
- 领导者等待来自大多数节点的 NEWLEADER 消息的响应。
- 当领导者接收到来自大多数节点的 NEWLEADER 消息的响应时，领导者设置 ZAB 状态为广播状态。
- 当跟随者接收到 UPTODATE 消息时，可以处理写请求了，就设置 ZAB 状态为广播。

***在 ZooKeeper 中，被复制到大多数节点上的提案，最终会被提交，并不会再改变；而只在少数节点存在的提案，可能会被提交和不再改变，也可能会被删除。***

如果写请求对应的提案“SET X = 1”已经复制到大多数节点上，那么它是最终会被提交，之后也不会再改变。也就是说，在没有新的 X 赋值操作的前提下，不管节点怎么崩溃、领导者如何变更，你查询到的 X 的值都为 1。

如果写请求对应的提案“SET X = 1”未被复制到大多数节点上，比如在领导者广播消息过程中，领导者崩溃了，那么，提案“SET X = 1”，可能被复制到大多数节点上，并提交和之后就不再改变，也可能会被删除。这个行为是未确定的，取决于新的领导者是否包含该提案。

***在 ZAB 中，选举出了新的领导者后，该领导者不能立即处理写请求，还需要通过成员发现、数据同步 2 个阶段进行故障恢复。这是 ZAB 协议的设计决定的，不是所有的共识算法都必须这样，比如 Raft 选举出新的领导者后，领导者是可以立即处理写请求的。***

