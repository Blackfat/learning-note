#### java运行时的数据区域

![1353310](https://user-images.githubusercontent.com/13096375/53457827-a2950700-3a6e-11e9-9037-30d7e07472ca.png)

- 程序计数器：是一块较小的内存空间，如果线程正在执行java方法，则存放的是虚拟机指令地址，如果线程执行的是native方法，计数器值为空。此区域没有规定任何OutOfMemoryError异常。
- java虚拟机栈：描述java方法执行的内存模型，每个方法执行都会创建一个帧栈，如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
- 本地方法栈：为虚拟机使用native方法服务。
- java堆：所有线程共享的一块内存区域，如果在堆中没有内存完成实例分配，且堆也无法扩展，将抛出OutOfMemoryError。
- 方法区：用于存储已被虚拟机加载的类信息，常量，静态属性等，jdk1.7中已经把字符串常量池从方法区移除到堆中。
- 运行时常量：运行时常量是方法区的 一部分。class文件中除了有类的版本，字段，接口等描述信息外，还有一项是常量池，用于存放各种编译时产生的字面量和符号引用（代替实际运行时的内存地址）。

#### Java内存模型

> 出现线程安全问题一般是因为主内存和工作内存数据不一致和重排序（编译器指令重排序和处理器指令重排序 ）导致的。为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。

#####JMM

共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。 JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。

##### 重排序

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
- 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**，处理器可以改变语句对应机器指令的执行顺序；
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 

**针对编译器重排序**，JMM的编译器重排序规则会禁止一些**特定类型的编译器重排序**；**针对处理器重排序**，编译器在生成指令序列的时候会通过**插入内存屏障指令来禁止某些特殊的处理器重排序**。 

##### happens-before

- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
- 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）

线程间的happens-before关系

1. 解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。
2. volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。 
3. 线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。 
4. 线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）。 
5. 线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。
6. 构造器中的最后一个操作 happens-before 析构器的第一个操作。 

#### java对象的内存布局

HotSpot虚拟机中，一个java对象由3个部分组成：

- 对象头
- 类定义的实例数据
- 内存对齐

对象头

对象头又分为MarkWork和类型指针（每种对象实例在方法区都会与一个Class对象与之相对应。对象头的类型指针便是用来定位它的类的元数据 ，主要是为了方法区在垃圾回收的时候，对应的class对象不会被回收）

内存对齐

HotSpot要求对象的起止地址必须是8的倍数 ，主要是为了加快cpu的内存访问速度


#### 虚拟机中的垃圾回收算法 

新生代的垃圾回收器：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是标记 - 复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New
类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。

老年的垃圾回收器：Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。

>堆是共享的，所有的线程都会在堆上分配内存，那么jvm是如何保证内存分配是线程安全的？答案是，每
>个线程都会有TLAB(thread local allocation buffer)，这个是线程私有的。首先会在TLAB上分配，如果
>TLAB不够用，就需要通过加锁的方式，申请TLAB。

Minor GC 的另外一个好处是不用对整个堆进行垃圾回收,但可能存在老年代对象可能引用新生代的对象。这个时候理论上是需要扫描老年代的对象，但jvm做了优化。在进行 Minor GC 的时候，可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。

>HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

minorGC的触发条件：在eden区分配内存时，发现空间不足。

CMS GC的触发条件：旧生代已经使用的空间达到设定的百分比时 。

Full GC的触发条件：旧生代空间不足 ；统计得到的minor GC晋升到旧生代的平均大小大于旧生代的剩余空间 ；

CMS GC时出现promotion failed  和concurrent  mode failure 。

>promotion failed:Minor GC后， Survivor空间容纳不了剩余对象，将要放入老年代，老年代有碎片或者不能容纳这些对象 ，导致promotion failed。
>
>concurrent  mode failure ：CMS是和业务线程并发运行的，在执行CMS的过程中有业务对象需要在老年代直接分配 ，但是老年代没有足够的空间来分配，所以导致concurrent mode failure。



####synchronized

>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。频繁的线程阻塞或唤醒会消耗很多的cpu处理时间。

重量级锁

>重量级锁会阻塞、唤醒请求加锁的线程。它针对的是多个线程同时竞争同一把锁的情况。Java 虚拟机 采取了自适应自旋，来避免线程在面对非常小的 synchronized 代码块时，仍会被阻塞、唤醒的情况。 

java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。 为了尽量避免昂贵的线程阻塞、唤醒操作，Java 虚拟机会在线程进入阻塞状态之前，以及被唤醒后竞 争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放 了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。 与线程阻塞相比，自旋状态可能会浪费大量的处理器资源。这是因为当前线程仍处于运行状况，只不过 跑的是无用指令。它期望在运行无用指令的过程中，锁能够被释放出来。 自旋状态还带来另外一个副作用，那便是不公平的锁机制。处于阻塞状态的线程，并没有办法立刻竞争 被释放的锁。然而，处于自旋状态的线程，则很有可能优先获得这把锁。 

轻量级锁

>轻量级锁采用 CAS 操作，将锁对象的标记字段替换为一个指针，指向当前线程栈上的一块空间，存储 着锁对象原本的标记字段。它针对的是多个线程在不同时间段申请同一把锁的情况。 

多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争。针对这种情形，Java 虚拟机采用了轻 量级锁，来避免重量级锁的阻塞以及唤醒。 

偏向锁

>偏向锁只会在第一次请求时采用 CAS 操作，在锁对象的标记字段中记录下当前线程的地址。在之后的 运行过程中，持有该偏向锁的线程的加锁操作将直接返回。它针对的是锁仅会被同一线程持有的情况。 

从始至终只有一个线程请求某一把锁。 

![32位hotspotmarkword](https://user-images.githubusercontent.com/13096375/50806266-dab28000-1330-11e9-9546-c4ec05f2e5b9.jpg)

总结：锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级** 。



