#### java运行时的数据区域

![1353310](https://user-images.githubusercontent.com/13096375/53457827-a2950700-3a6e-11e9-9037-30d7e07472ca.png)

- 程序计数器：是一块较小的内存空间，可以看成是当前线程所执行字节码的行号指示器，如果线程正在执行java方法，则存放的是虚拟机指令地址，如果线程执行的是native方法，计数器值为空。此区域没有规定任何OutOfMemoryError异常。
- java虚拟机栈：描述java方法执行的内存模型，每个方法执行都会创建一个帧栈，如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
- 本地方法栈：为虚拟机使用native方法服务。
- java堆：所有线程共享的一块内存区域，如果在堆中没有内存完成实例分配，且堆也无法扩展，将抛出OutOfMemoryError。
- 方法区：用于存储已被虚拟机加载的类信息，常量，静态属性等，jdk1.7中已经把字符串常量池从方法区移除到堆中。
- 运行时常量：运行时常量是方法区的 一部分。class文件中除了有类的版本，字段，接口等描述信息外，还有一项是常量池，用于存放各种编译时产生的字面量和符号引用（代替实际运行时的内存地址）。

#### 常量池

- `class常量池` 是在编译的时候每个class都有的，在编译阶段，存放的是常量的 **符号引用** 。

  字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值。

  符号引用 是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。一般包括下面三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

- `字符串常量池` 在每个VM中只有一份，存放的是字符串常量的 **引用值** 。

- `运行时常量池` 是在类加载完成之后，将每个`class常量池` 中的符号引用值转存到 `运行时常量池` 中，也就是说，每个class都有一个 `运行时常量池` ，类在 **解析阶段** ，将 符号引用 替换成 直接引用 ，与 `字符串常量池` 中的引用值保持一致。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。

#### Java内存模型

> 出现线程安全问题一般是因为主内存和工作内存数据不一致和重排序（编译器指令重排序和处理器指令重排序 ）导致的。为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。

#####JMM

共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。 JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。

##### 重排序

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
- 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**，处理器可以改变语句对应机器指令的执行顺序；
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 

**针对编译器重排序**，JMM的编译器重排序规则会禁止一些**特定类型的编译器重排序**；**针对处理器重排序**，编译器在生成指令序列的时候会通过**插入内存屏障指令来禁止某些特殊的处理器重排序**。 

##### happens-before

- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
- 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）

线程间的happens-before关系

1. 解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。
2. volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。 
3. 线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。 
4. 线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）。 
5. 线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。
6. 构造器中的最后一个操作 happens-before 析构器的第一个操作。 

##### volatile和synchronized的内存语义

进入 synchronized 时，使得本地缓存失效，synchronized 块中对共享变量的读取必须从主内存读取；退出 synchronized 时，会将进入 synchronized 块之前和 synchronized 块中的写操作刷入到主存中。

读一个 volatile 变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个 volatile 属性会立即刷入到主内存。所以，volatile 读和 monitorenter 有相同的语义，volatile 写和 monitorexit 有相同的语义。

为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。StoreLoad屏障是避免volatile写与后面可能有的volatile读/写操作重排序。LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。

##### cas的内存语义

由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。

1）A线程写volatile变量，随后B线程读这个volatile变量。

2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。

3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。

4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。

#### java对象的内存布局

HotSpot虚拟机中，一个java对象由3个部分组成：

- 对象头
- 类定义的实例数据
- 内存对齐

对象头

对象头又分为MarkWork和类型指针（每种对象实例在方法区都会与一个Class对象与之相对应。对象头的类型指针便是用来定位它的类的元数据 ，主要是为了方法区在垃圾回收的时候，对应的class对象不会被回收）

内存对齐

HotSpot要求对象的起止地址必须是8的倍数 ，主要是为了加快cpu的内存访问速度

####synchronized

>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。频繁的线程阻塞或唤醒会消耗很多的cpu处理时间。

重量级锁

>重量级锁会阻塞、唤醒请求加锁的线程。它针对的是多个线程同时竞争同一把锁的情况。Java 虚拟机 采取了自适应自旋，来避免线程在面对非常小的 synchronized 代码块时，仍会被阻塞、唤醒的情况。 

java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。 为了尽量避免昂贵的线程阻塞、唤醒操作，Java 虚拟机会在线程进入阻塞状态之前，以及被唤醒后竞 争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放 了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。 与线程阻塞相比，自旋状态可能会浪费大量的处理器资源。这是因为当前线程仍处于运行状况，只不过 跑的是无用指令。它期望在运行无用指令的过程中，锁能够被释放出来。 自旋状态还带来另外一个副作用，那便是不公平的锁机制。处于阻塞状态的线程，并没有办法立刻竞争 被释放的锁。然而，处于自旋状态的线程，则很有可能优先获得这把锁。 

轻量级锁

>轻量级锁采用 CAS 操作，将锁对象的标记字段替换为一个指针，指向当前线程栈上的一块空间，存储 着锁对象原本的标记字段。它针对的是多个线程在不同时间段申请同一把锁的情况。 

多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争。针对这种情形，Java 虚拟机采用了轻 量级锁，来避免重量级锁的阻塞以及唤醒。 

偏向锁

>偏向锁只会在第一次请求时采用 CAS 操作，在锁对象的标记字段中记录下当前线程的地址。在之后的 运行过程中，持有该偏向锁的线程的加锁操作将直接返回。它针对的是锁仅会被同一线程持有的情况。 

从始至终只有一个线程请求某一把锁。 

![32位hotspotmarkword](https://user-images.githubusercontent.com/13096375/50806266-dab28000-1330-11e9-9546-c4ec05f2e5b9.jpg)

总结：锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级** 。



